//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getEmployees(userNameFilter: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/GetEmployees?";
        if (userNameFilter !== undefined && userNameFilter !== null)
            url_ += "userNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetEmployees(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(loginVM: LoginVM): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginVM);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createEmployee(imageFile: FileParameter | null | undefined, username: string | null | undefined, password: string | null | undefined, email: string | null | undefined, lastName: string | null | undefined, firstName: string | null | undefined, middleName: string | null | undefined, extentName: string | null | undefined, phoneNumber: string | null | undefined, gender: string | null | undefined, birthDate: Date | undefined, placeBirth: string | null | undefined, bloodType: string | null | undefined, height: string | null | undefined, weight: string | null | undefined, citizenship: string | null | undefined, civilStatus: string | null | undefined, religion: string | null | undefined, ethnicity: string | null | undefined, tribalAffiliation: string | null | undefined, presentAddress: string | null | undefined, presentCityMun: string | null | undefined, presentProvince: string | null | undefined, presentZip: string | null | undefined, permanentAddress: string | null | undefined, permanentCityMun: string | null | undefined, permanentProvince: string | null | undefined, permanentZip: string | null | undefined, dateHired: Date | undefined, nationalIDNo: string | null | undefined, tINNo: string | null | undefined, sSSNo: string | null | undefined, pagibigNo: string | null | undefined, philHealthNo: string | null | undefined, spouseFullName: string | null | undefined, spouseContactNo: string | null | undefined, spouseOccupation: string | null | undefined, spouseCompanyName: string | null | undefined, spouseCompanyAdd: string | null | undefined, fatherName: string | null | undefined, fatherOccupation: string | null | undefined, motherName: string | null | undefined, motherOccupation: string | null | undefined, govLicensureExam: string | null | undefined, dateExam: string | null | undefined, rating: string | null | undefined, regNo: string | null | undefined, placeofExam: string | null | undefined, dateRegitered: string | null | undefined, validity: string | null | undefined, remarks: string | null | undefined, primarySchool: string | null | undefined, primaryAcademicHonor: string | null | undefined, primaryYearGraduated: string | null | undefined, secondarySchool: string | null | undefined, secondaryAcademicHonor: string | null | undefined, secondaryYearGraduated: string | null | undefined, tertiarySchool: string | null | undefined, tertiaryAcademicHonor: string | null | undefined, degreeEarned: string | null | undefined, major: string | null | undefined, tertiaryYearGraduated: string | null | undefined, mastersSchool: string | null | undefined, mastersAcademicHonor: string | null | undefined, mastersDegreeEarned: string | null | undefined, mastersMajor: string | null | undefined, mastersYearGraduated: string | null | undefined, phdSchool: string | null | undefined, phdAcademicHonor: string | null | undefined, phdDegreeEarned: string | null | undefined, phdMajor: string | null | undefined, phdYearGraduated: string | null | undefined, positionName: string | null | undefined, employeeNumber: string | null | undefined, departmentName: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/CreateEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imageFile !== null && imageFile !== undefined)
            content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");
        if (username !== null && username !== undefined)
            content_.append("Username", username.toString());
        if (password !== null && password !== undefined)
            content_.append("Password", password.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (lastName !== null && lastName !== undefined)
            content_.append("LastName", lastName.toString());
        if (firstName !== null && firstName !== undefined)
            content_.append("FirstName", firstName.toString());
        if (middleName !== null && middleName !== undefined)
            content_.append("MiddleName", middleName.toString());
        if (extentName !== null && extentName !== undefined)
            content_.append("ExtentName", extentName.toString());
        if (phoneNumber !== null && phoneNumber !== undefined)
            content_.append("PhoneNumber", phoneNumber.toString());
        if (gender !== null && gender !== undefined)
            content_.append("Gender", gender.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toJSON());
        if (placeBirth !== null && placeBirth !== undefined)
            content_.append("PlaceBirth", placeBirth.toString());
        if (bloodType !== null && bloodType !== undefined)
            content_.append("BloodType", bloodType.toString());
        if (height !== null && height !== undefined)
            content_.append("Height", height.toString());
        if (weight !== null && weight !== undefined)
            content_.append("Weight", weight.toString());
        if (citizenship !== null && citizenship !== undefined)
            content_.append("Citizenship", citizenship.toString());
        if (civilStatus !== null && civilStatus !== undefined)
            content_.append("CivilStatus", civilStatus.toString());
        if (religion !== null && religion !== undefined)
            content_.append("Religion", religion.toString());
        if (ethnicity !== null && ethnicity !== undefined)
            content_.append("Ethnicity", ethnicity.toString());
        if (tribalAffiliation !== null && tribalAffiliation !== undefined)
            content_.append("TribalAffiliation", tribalAffiliation.toString());
        if (presentAddress !== null && presentAddress !== undefined)
            content_.append("PresentAddress", presentAddress.toString());
        if (presentCityMun !== null && presentCityMun !== undefined)
            content_.append("PresentCityMun", presentCityMun.toString());
        if (presentProvince !== null && presentProvince !== undefined)
            content_.append("PresentProvince", presentProvince.toString());
        if (presentZip !== null && presentZip !== undefined)
            content_.append("PresentZip", presentZip.toString());
        if (permanentAddress !== null && permanentAddress !== undefined)
            content_.append("PermanentAddress", permanentAddress.toString());
        if (permanentCityMun !== null && permanentCityMun !== undefined)
            content_.append("PermanentCityMun", permanentCityMun.toString());
        if (permanentProvince !== null && permanentProvince !== undefined)
            content_.append("PermanentProvince", permanentProvince.toString());
        if (permanentZip !== null && permanentZip !== undefined)
            content_.append("PermanentZip", permanentZip.toString());
        if (dateHired === null || dateHired === undefined)
            throw new Error("The parameter 'dateHired' cannot be null.");
        else
            content_.append("DateHired", dateHired.toJSON());
        if (nationalIDNo !== null && nationalIDNo !== undefined)
            content_.append("NationalIDNo", nationalIDNo.toString());
        if (tINNo !== null && tINNo !== undefined)
            content_.append("TINNo", tINNo.toString());
        if (sSSNo !== null && sSSNo !== undefined)
            content_.append("SSSNo", sSSNo.toString());
        if (pagibigNo !== null && pagibigNo !== undefined)
            content_.append("PagibigNo", pagibigNo.toString());
        if (philHealthNo !== null && philHealthNo !== undefined)
            content_.append("PhilHealthNo", philHealthNo.toString());
        if (spouseFullName !== null && spouseFullName !== undefined)
            content_.append("SpouseFullName", spouseFullName.toString());
        if (spouseContactNo !== null && spouseContactNo !== undefined)
            content_.append("SpouseContactNo", spouseContactNo.toString());
        if (spouseOccupation !== null && spouseOccupation !== undefined)
            content_.append("SpouseOccupation", spouseOccupation.toString());
        if (spouseCompanyName !== null && spouseCompanyName !== undefined)
            content_.append("SpouseCompanyName", spouseCompanyName.toString());
        if (spouseCompanyAdd !== null && spouseCompanyAdd !== undefined)
            content_.append("SpouseCompanyAdd", spouseCompanyAdd.toString());
        if (fatherName !== null && fatherName !== undefined)
            content_.append("FatherName", fatherName.toString());
        if (fatherOccupation !== null && fatherOccupation !== undefined)
            content_.append("FatherOccupation", fatherOccupation.toString());
        if (motherName !== null && motherName !== undefined)
            content_.append("MotherName", motherName.toString());
        if (motherOccupation !== null && motherOccupation !== undefined)
            content_.append("MotherOccupation", motherOccupation.toString());
        if (govLicensureExam !== null && govLicensureExam !== undefined)
            content_.append("GovLicensureExam", govLicensureExam.toString());
        if (dateExam !== null && dateExam !== undefined)
            content_.append("DateExam", dateExam.toString());
        if (rating !== null && rating !== undefined)
            content_.append("Rating", rating.toString());
        if (regNo !== null && regNo !== undefined)
            content_.append("RegNo", regNo.toString());
        if (placeofExam !== null && placeofExam !== undefined)
            content_.append("PlaceofExam", placeofExam.toString());
        if (dateRegitered !== null && dateRegitered !== undefined)
            content_.append("DateRegitered", dateRegitered.toString());
        if (validity !== null && validity !== undefined)
            content_.append("Validity", validity.toString());
        if (remarks !== null && remarks !== undefined)
            content_.append("Remarks", remarks.toString());
        if (primarySchool !== null && primarySchool !== undefined)
            content_.append("PrimarySchool", primarySchool.toString());
        if (primaryAcademicHonor !== null && primaryAcademicHonor !== undefined)
            content_.append("PrimaryAcademicHonor", primaryAcademicHonor.toString());
        if (primaryYearGraduated !== null && primaryYearGraduated !== undefined)
            content_.append("PrimaryYearGraduated", primaryYearGraduated.toString());
        if (secondarySchool !== null && secondarySchool !== undefined)
            content_.append("SecondarySchool", secondarySchool.toString());
        if (secondaryAcademicHonor !== null && secondaryAcademicHonor !== undefined)
            content_.append("SecondaryAcademicHonor", secondaryAcademicHonor.toString());
        if (secondaryYearGraduated !== null && secondaryYearGraduated !== undefined)
            content_.append("SecondaryYearGraduated", secondaryYearGraduated.toString());
        if (tertiarySchool !== null && tertiarySchool !== undefined)
            content_.append("TertiarySchool", tertiarySchool.toString());
        if (tertiaryAcademicHonor !== null && tertiaryAcademicHonor !== undefined)
            content_.append("TertiaryAcademicHonor", tertiaryAcademicHonor.toString());
        if (degreeEarned !== null && degreeEarned !== undefined)
            content_.append("DegreeEarned", degreeEarned.toString());
        if (major !== null && major !== undefined)
            content_.append("Major", major.toString());
        if (tertiaryYearGraduated !== null && tertiaryYearGraduated !== undefined)
            content_.append("TertiaryYearGraduated", tertiaryYearGraduated.toString());
        if (mastersSchool !== null && mastersSchool !== undefined)
            content_.append("MastersSchool", mastersSchool.toString());
        if (mastersAcademicHonor !== null && mastersAcademicHonor !== undefined)
            content_.append("MastersAcademicHonor", mastersAcademicHonor.toString());
        if (mastersDegreeEarned !== null && mastersDegreeEarned !== undefined)
            content_.append("MastersDegreeEarned", mastersDegreeEarned.toString());
        if (mastersMajor !== null && mastersMajor !== undefined)
            content_.append("MastersMajor", mastersMajor.toString());
        if (mastersYearGraduated !== null && mastersYearGraduated !== undefined)
            content_.append("MastersYearGraduated", mastersYearGraduated.toString());
        if (phdSchool !== null && phdSchool !== undefined)
            content_.append("PhdSchool", phdSchool.toString());
        if (phdAcademicHonor !== null && phdAcademicHonor !== undefined)
            content_.append("PhdAcademicHonor", phdAcademicHonor.toString());
        if (phdDegreeEarned !== null && phdDegreeEarned !== undefined)
            content_.append("PhdDegreeEarned", phdDegreeEarned.toString());
        if (phdMajor !== null && phdMajor !== undefined)
            content_.append("PhdMajor", phdMajor.toString());
        if (phdYearGraduated !== null && phdYearGraduated !== undefined)
            content_.append("PhdYearGraduated", phdYearGraduated.toString());
        if (positionName !== null && positionName !== undefined)
            content_.append("PositionName", positionName.toString());
        if (employeeNumber !== null && employeeNumber !== undefined)
            content_.append("EmployeeNumber", employeeNumber.toString());
        if (departmentName !== null && departmentName !== undefined)
            content_.append("DepartmentName", departmentName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateEmployee(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateEmployee(id: string, userVm: HRMSUserVm): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/UpdateEmployee/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUpdateEmployee(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    initializeAdmin(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/InitializeAdmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitializeAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitializeAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processInitializeAdmin(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    initializeEmployee(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/InitializeEmployee";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitializeEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitializeEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processInitializeEmployee(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DataClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getLeaveBalance(): Observable<LeaveBalance> {
        let url_ = this.baseUrl + "/api/Data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeaveBalance>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeaveBalance>;
        }));
    }

    protected processGetLeaveBalance(response: HttpResponseBase): Observable<LeaveBalance> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveBalance.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class EmployeeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    updateDepartment(id: number, departments: Departments): Observable<Response> {
        let url_ = this.baseUrl + "/api/Employee/UpdateDepartment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(departments);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdateDepartment(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updatePosition(id: number, positions: Positions): Observable<Response> {
        let url_ = this.baseUrl + "/api/Employee/UpdatePosition/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(positions);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processUpdatePosition(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteDepartment(departmentId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Employee/Department/{departmentId}";
        if (departmentId === undefined || departmentId === null)
            throw new Error("The parameter 'departmentId' must be defined.");
        url_ = url_.replace("{departmentId}", encodeURIComponent("" + departmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteDepartment(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deletePosition(positionId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Employee/Position/{positionId}";
        if (positionId === undefined || positionId === null)
            throw new Error("The parameter 'positionId' must be defined.");
        url_ = url_.replace("{positionId}", encodeURIComponent("" + positionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeletePosition(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfDepartmentNameExists(departmentName: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Employee/CheckIfDepartmentNameExists?";
        if (departmentName !== undefined && departmentName !== null)
            url_ += "departmentName=" + encodeURIComponent("" + departmentName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfDepartmentNameExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfDepartmentNameExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCheckIfDepartmentNameExists(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDepartment(departmentNameFilter: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Employee/GetDepartment?";
        if (departmentNameFilter !== undefined && departmentNameFilter !== null)
            url_ += "departmentNameFilter=" + encodeURIComponent("" + departmentNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDepartment(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPositions(positionNameFilter: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Employee/GetPositions?";
        if (positionNameFilter !== undefined && positionNameFilter !== null)
            url_ += "positionNameFilter=" + encodeURIComponent("" + positionNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPositions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetPositions(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addPositions(positionVM: PositionsVM): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Employee/AddPositions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(positionVM);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPositions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processAddPositions(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addDepartments(departmentsVM: DepartmentsVM): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Employee/AddDepartments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(departmentsVM);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDepartments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processAddDepartments(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class LoginVM implements ILoginVM {
    username!: string;
    password!: string;

    constructor(data?: ILoginVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginVM {
        data = typeof data === 'object' ? data : {};
        let result = new LoginVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }

    clone(): LoginVM {
        const json = this.toJSON();
        let result = new LoginVM();
        result.init(json);
        return result;
    }
}

export interface ILoginVM {
    username: string;
    password: string;
}

export class HRMSUserVm implements IHRMSUserVm {
    imageFile?: any | undefined;
    username?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    extentName?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    birthDate!: Date;
    placeBirth?: string | undefined;
    bloodType?: string | undefined;
    height?: string | undefined;
    weight?: string | undefined;
    citizenship?: string | undefined;
    civilStatus?: string | undefined;
    religion?: string | undefined;
    ethnicity?: string | undefined;
    tribalAffiliation?: string | undefined;
    presentAddress?: string | undefined;
    presentCityMun?: string | undefined;
    presentProvince?: string | undefined;
    presentZip?: string | undefined;
    permanentAddress?: string | undefined;
    permanentCityMun?: string | undefined;
    permanentProvince?: string | undefined;
    permanentZip?: string | undefined;
    dateHired!: Date;
    nationalIDNo?: string | undefined;
    tinNo?: string | undefined;
    sssNo?: string | undefined;
    pagibigNo?: string | undefined;
    philHealthNo?: string | undefined;
    spouseFullName?: string | undefined;
    spouseContactNo?: string | undefined;
    spouseOccupation?: string | undefined;
    spouseCompanyName?: string | undefined;
    spouseCompanyAdd?: string | undefined;
    fatherName?: string | undefined;
    fatherOccupation?: string | undefined;
    motherName?: string | undefined;
    motherOccupation?: string | undefined;
    govLicensureExam?: string | undefined;
    dateExam?: string | undefined;
    rating?: string | undefined;
    regNo?: string | undefined;
    placeofExam?: string | undefined;
    dateRegitered?: string | undefined;
    validity?: string | undefined;
    remarks?: string | undefined;
    primarySchool?: string | undefined;
    primaryAcademicHonor?: string | undefined;
    primaryYearGraduated?: string | undefined;
    secondarySchool?: string | undefined;
    secondaryAcademicHonor?: string | undefined;
    secondaryYearGraduated?: string | undefined;
    tertiarySchool?: string | undefined;
    tertiaryAcademicHonor?: string | undefined;
    degreeEarned?: string | undefined;
    major?: string | undefined;
    tertiaryYearGraduated?: string | undefined;
    mastersSchool?: string | undefined;
    mastersAcademicHonor?: string | undefined;
    mastersDegreeEarned?: string | undefined;
    mastersMajor?: string | undefined;
    mastersYearGraduated?: string | undefined;
    phdSchool?: string | undefined;
    phdAcademicHonor?: string | undefined;
    phdDegreeEarned?: string | undefined;
    phdMajor?: string | undefined;
    phdYearGraduated?: string | undefined;
    positionName?: string | undefined;
    employeeNumber?: string | undefined;
    departmentName?: string | undefined;

    constructor(data?: IHRMSUserVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageFile = _data["imageFile"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.extentName = _data["extentName"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.placeBirth = _data["placeBirth"];
            this.bloodType = _data["bloodType"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.citizenship = _data["citizenship"];
            this.civilStatus = _data["civilStatus"];
            this.religion = _data["religion"];
            this.ethnicity = _data["ethnicity"];
            this.tribalAffiliation = _data["tribalAffiliation"];
            this.presentAddress = _data["presentAddress"];
            this.presentCityMun = _data["presentCityMun"];
            this.presentProvince = _data["presentProvince"];
            this.presentZip = _data["presentZip"];
            this.permanentAddress = _data["permanentAddress"];
            this.permanentCityMun = _data["permanentCityMun"];
            this.permanentProvince = _data["permanentProvince"];
            this.permanentZip = _data["permanentZip"];
            this.dateHired = _data["dateHired"] ? new Date(_data["dateHired"].toString()) : <any>undefined;
            this.nationalIDNo = _data["nationalIDNo"];
            this.tinNo = _data["tinNo"];
            this.sssNo = _data["sssNo"];
            this.pagibigNo = _data["pagibigNo"];
            this.philHealthNo = _data["philHealthNo"];
            this.spouseFullName = _data["spouseFullName"];
            this.spouseContactNo = _data["spouseContactNo"];
            this.spouseOccupation = _data["spouseOccupation"];
            this.spouseCompanyName = _data["spouseCompanyName"];
            this.spouseCompanyAdd = _data["spouseCompanyAdd"];
            this.fatherName = _data["fatherName"];
            this.fatherOccupation = _data["fatherOccupation"];
            this.motherName = _data["motherName"];
            this.motherOccupation = _data["motherOccupation"];
            this.govLicensureExam = _data["govLicensureExam"];
            this.dateExam = _data["dateExam"];
            this.rating = _data["rating"];
            this.regNo = _data["regNo"];
            this.placeofExam = _data["placeofExam"];
            this.dateRegitered = _data["dateRegitered"];
            this.validity = _data["validity"];
            this.remarks = _data["remarks"];
            this.primarySchool = _data["primarySchool"];
            this.primaryAcademicHonor = _data["primaryAcademicHonor"];
            this.primaryYearGraduated = _data["primaryYearGraduated"];
            this.secondarySchool = _data["secondarySchool"];
            this.secondaryAcademicHonor = _data["secondaryAcademicHonor"];
            this.secondaryYearGraduated = _data["secondaryYearGraduated"];
            this.tertiarySchool = _data["tertiarySchool"];
            this.tertiaryAcademicHonor = _data["tertiaryAcademicHonor"];
            this.degreeEarned = _data["degreeEarned"];
            this.major = _data["major"];
            this.tertiaryYearGraduated = _data["tertiaryYearGraduated"];
            this.mastersSchool = _data["mastersSchool"];
            this.mastersAcademicHonor = _data["mastersAcademicHonor"];
            this.mastersDegreeEarned = _data["mastersDegreeEarned"];
            this.mastersMajor = _data["mastersMajor"];
            this.mastersYearGraduated = _data["mastersYearGraduated"];
            this.phdSchool = _data["phdSchool"];
            this.phdAcademicHonor = _data["phdAcademicHonor"];
            this.phdDegreeEarned = _data["phdDegreeEarned"];
            this.phdMajor = _data["phdMajor"];
            this.phdYearGraduated = _data["phdYearGraduated"];
            this.positionName = _data["positionName"];
            this.employeeNumber = _data["employeeNumber"];
            this.departmentName = _data["departmentName"];
        }
    }

    static fromJS(data: any): HRMSUserVm {
        data = typeof data === 'object' ? data : {};
        let result = new HRMSUserVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageFile"] = this.imageFile;
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["extentName"] = this.extentName;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["placeBirth"] = this.placeBirth;
        data["bloodType"] = this.bloodType;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["citizenship"] = this.citizenship;
        data["civilStatus"] = this.civilStatus;
        data["religion"] = this.religion;
        data["ethnicity"] = this.ethnicity;
        data["tribalAffiliation"] = this.tribalAffiliation;
        data["presentAddress"] = this.presentAddress;
        data["presentCityMun"] = this.presentCityMun;
        data["presentProvince"] = this.presentProvince;
        data["presentZip"] = this.presentZip;
        data["permanentAddress"] = this.permanentAddress;
        data["permanentCityMun"] = this.permanentCityMun;
        data["permanentProvince"] = this.permanentProvince;
        data["permanentZip"] = this.permanentZip;
        data["dateHired"] = this.dateHired ? this.dateHired.toISOString() : <any>undefined;
        data["nationalIDNo"] = this.nationalIDNo;
        data["tinNo"] = this.tinNo;
        data["sssNo"] = this.sssNo;
        data["pagibigNo"] = this.pagibigNo;
        data["philHealthNo"] = this.philHealthNo;
        data["spouseFullName"] = this.spouseFullName;
        data["spouseContactNo"] = this.spouseContactNo;
        data["spouseOccupation"] = this.spouseOccupation;
        data["spouseCompanyName"] = this.spouseCompanyName;
        data["spouseCompanyAdd"] = this.spouseCompanyAdd;
        data["fatherName"] = this.fatherName;
        data["fatherOccupation"] = this.fatherOccupation;
        data["motherName"] = this.motherName;
        data["motherOccupation"] = this.motherOccupation;
        data["govLicensureExam"] = this.govLicensureExam;
        data["dateExam"] = this.dateExam;
        data["rating"] = this.rating;
        data["regNo"] = this.regNo;
        data["placeofExam"] = this.placeofExam;
        data["dateRegitered"] = this.dateRegitered;
        data["validity"] = this.validity;
        data["remarks"] = this.remarks;
        data["primarySchool"] = this.primarySchool;
        data["primaryAcademicHonor"] = this.primaryAcademicHonor;
        data["primaryYearGraduated"] = this.primaryYearGraduated;
        data["secondarySchool"] = this.secondarySchool;
        data["secondaryAcademicHonor"] = this.secondaryAcademicHonor;
        data["secondaryYearGraduated"] = this.secondaryYearGraduated;
        data["tertiarySchool"] = this.tertiarySchool;
        data["tertiaryAcademicHonor"] = this.tertiaryAcademicHonor;
        data["degreeEarned"] = this.degreeEarned;
        data["major"] = this.major;
        data["tertiaryYearGraduated"] = this.tertiaryYearGraduated;
        data["mastersSchool"] = this.mastersSchool;
        data["mastersAcademicHonor"] = this.mastersAcademicHonor;
        data["mastersDegreeEarned"] = this.mastersDegreeEarned;
        data["mastersMajor"] = this.mastersMajor;
        data["mastersYearGraduated"] = this.mastersYearGraduated;
        data["phdSchool"] = this.phdSchool;
        data["phdAcademicHonor"] = this.phdAcademicHonor;
        data["phdDegreeEarned"] = this.phdDegreeEarned;
        data["phdMajor"] = this.phdMajor;
        data["phdYearGraduated"] = this.phdYearGraduated;
        data["positionName"] = this.positionName;
        data["employeeNumber"] = this.employeeNumber;
        data["departmentName"] = this.departmentName;
        return data;
    }

    clone(): HRMSUserVm {
        const json = this.toJSON();
        let result = new HRMSUserVm();
        result.init(json);
        return result;
    }
}

export interface IHRMSUserVm {
    imageFile?: any | undefined;
    username?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    extentName?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    birthDate: Date;
    placeBirth?: string | undefined;
    bloodType?: string | undefined;
    height?: string | undefined;
    weight?: string | undefined;
    citizenship?: string | undefined;
    civilStatus?: string | undefined;
    religion?: string | undefined;
    ethnicity?: string | undefined;
    tribalAffiliation?: string | undefined;
    presentAddress?: string | undefined;
    presentCityMun?: string | undefined;
    presentProvince?: string | undefined;
    presentZip?: string | undefined;
    permanentAddress?: string | undefined;
    permanentCityMun?: string | undefined;
    permanentProvince?: string | undefined;
    permanentZip?: string | undefined;
    dateHired: Date;
    nationalIDNo?: string | undefined;
    tinNo?: string | undefined;
    sssNo?: string | undefined;
    pagibigNo?: string | undefined;
    philHealthNo?: string | undefined;
    spouseFullName?: string | undefined;
    spouseContactNo?: string | undefined;
    spouseOccupation?: string | undefined;
    spouseCompanyName?: string | undefined;
    spouseCompanyAdd?: string | undefined;
    fatherName?: string | undefined;
    fatherOccupation?: string | undefined;
    motherName?: string | undefined;
    motherOccupation?: string | undefined;
    govLicensureExam?: string | undefined;
    dateExam?: string | undefined;
    rating?: string | undefined;
    regNo?: string | undefined;
    placeofExam?: string | undefined;
    dateRegitered?: string | undefined;
    validity?: string | undefined;
    remarks?: string | undefined;
    primarySchool?: string | undefined;
    primaryAcademicHonor?: string | undefined;
    primaryYearGraduated?: string | undefined;
    secondarySchool?: string | undefined;
    secondaryAcademicHonor?: string | undefined;
    secondaryYearGraduated?: string | undefined;
    tertiarySchool?: string | undefined;
    tertiaryAcademicHonor?: string | undefined;
    degreeEarned?: string | undefined;
    major?: string | undefined;
    tertiaryYearGraduated?: string | undefined;
    mastersSchool?: string | undefined;
    mastersAcademicHonor?: string | undefined;
    mastersDegreeEarned?: string | undefined;
    mastersMajor?: string | undefined;
    mastersYearGraduated?: string | undefined;
    phdSchool?: string | undefined;
    phdAcademicHonor?: string | undefined;
    phdDegreeEarned?: string | undefined;
    phdMajor?: string | undefined;
    phdYearGraduated?: string | undefined;
    positionName?: string | undefined;
    employeeNumber?: string | undefined;
    departmentName?: string | undefined;
}

export class LeaveBalance implements ILeaveBalance {
    id!: number;
    employee?: EmployeeEntity | undefined;
    leaveTotal!: number;
    leaveUsed!: number;
    leaveAccepted!: number;
    leaveRejected!: number;
    leaveExpired!: number;
    timeStamp!: Date;

    constructor(data?: ILeaveBalance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employee = _data["employee"] ? EmployeeEntity.fromJS(_data["employee"]) : <any>undefined;
            this.leaveTotal = _data["leaveTotal"];
            this.leaveUsed = _data["leaveUsed"];
            this.leaveAccepted = _data["leaveAccepted"];
            this.leaveRejected = _data["leaveRejected"];
            this.leaveExpired = _data["leaveExpired"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveBalance {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveBalance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["leaveTotal"] = this.leaveTotal;
        data["leaveUsed"] = this.leaveUsed;
        data["leaveAccepted"] = this.leaveAccepted;
        data["leaveRejected"] = this.leaveRejected;
        data["leaveExpired"] = this.leaveExpired;
        data["timeStamp"] = this.timeStamp ? formatDate(this.timeStamp) : <any>undefined;
        return data;
    }

    clone(): LeaveBalance {
        const json = this.toJSON();
        let result = new LeaveBalance();
        result.init(json);
        return result;
    }
}

export interface ILeaveBalance {
    id: number;
    employee?: EmployeeEntity | undefined;
    leaveTotal: number;
    leaveUsed: number;
    leaveAccepted: number;
    leaveRejected: number;
    leaveExpired: number;
    timeStamp: Date;
}

export class EmployeeEntity implements IEmployeeEntity {
    id!: number;
    lName?: string | undefined;
    fName?: string | undefined;
    midName?: string | undefined;
    extenName?: string | undefined;
    gender?: string | undefined;
    birthDate?: string | undefined;
    buildingNo?: string | undefined;
    street?: string | undefined;
    unitNo?: string | undefined;
    building?: string | undefined;
    province?: string | undefined;
    cityMun?: string | undefined;
    barangay?: string | undefined;
    zipCode?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    employeeEducationalBackgrounds?: EmployeeEducationalBackgroundEntity[] | undefined;
    employeeSkills?: EmployeeSkillEntity[] | undefined;
    employeeWorkExperiences?: EmployeeWorkExperienceEntity[] | undefined;
    departmentEntity?: DepartmentEntity | undefined;
    employeeStatus?: string | undefined;
    uploadImg?: string | undefined;
    uploadResume?: string | undefined;
    dateCreated!: Date;
    timeStamp!: Date;

    constructor(data?: IEmployeeEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lName = _data["lName"];
            this.fName = _data["fName"];
            this.midName = _data["midName"];
            this.extenName = _data["extenName"];
            this.gender = _data["gender"];
            this.birthDate = _data["birthDate"];
            this.buildingNo = _data["buildingNo"];
            this.street = _data["street"];
            this.unitNo = _data["unitNo"];
            this.building = _data["building"];
            this.province = _data["province"];
            this.cityMun = _data["cityMun"];
            this.barangay = _data["barangay"];
            this.zipCode = _data["zipCode"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            if (Array.isArray(_data["employeeEducationalBackgrounds"])) {
                this.employeeEducationalBackgrounds = [] as any;
                for (let item of _data["employeeEducationalBackgrounds"])
                    this.employeeEducationalBackgrounds!.push(EmployeeEducationalBackgroundEntity.fromJS(item));
            }
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkillEntity.fromJS(item));
            }
            if (Array.isArray(_data["employeeWorkExperiences"])) {
                this.employeeWorkExperiences = [] as any;
                for (let item of _data["employeeWorkExperiences"])
                    this.employeeWorkExperiences!.push(EmployeeWorkExperienceEntity.fromJS(item));
            }
            this.departmentEntity = _data["departmentEntity"] ? DepartmentEntity.fromJS(_data["departmentEntity"]) : <any>undefined;
            this.employeeStatus = _data["employeeStatus"];
            this.uploadImg = _data["uploadImg"];
            this.uploadResume = _data["uploadResume"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeEntity {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lName"] = this.lName;
        data["fName"] = this.fName;
        data["midName"] = this.midName;
        data["extenName"] = this.extenName;
        data["gender"] = this.gender;
        data["birthDate"] = this.birthDate;
        data["buildingNo"] = this.buildingNo;
        data["street"] = this.street;
        data["unitNo"] = this.unitNo;
        data["building"] = this.building;
        data["province"] = this.province;
        data["cityMun"] = this.cityMun;
        data["barangay"] = this.barangay;
        data["zipCode"] = this.zipCode;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        if (Array.isArray(this.employeeEducationalBackgrounds)) {
            data["employeeEducationalBackgrounds"] = [];
            for (let item of this.employeeEducationalBackgrounds)
                data["employeeEducationalBackgrounds"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeWorkExperiences)) {
            data["employeeWorkExperiences"] = [];
            for (let item of this.employeeWorkExperiences)
                data["employeeWorkExperiences"].push(item.toJSON());
        }
        data["departmentEntity"] = this.departmentEntity ? this.departmentEntity.toJSON() : <any>undefined;
        data["employeeStatus"] = this.employeeStatus;
        data["uploadImg"] = this.uploadImg;
        data["uploadResume"] = this.uploadResume;
        data["dateCreated"] = this.dateCreated ? formatDate(this.dateCreated) : <any>undefined;
        data["timeStamp"] = this.timeStamp ? formatDate(this.timeStamp) : <any>undefined;
        return data;
    }

    clone(): EmployeeEntity {
        const json = this.toJSON();
        let result = new EmployeeEntity();
        result.init(json);
        return result;
    }
}

export interface IEmployeeEntity {
    id: number;
    lName?: string | undefined;
    fName?: string | undefined;
    midName?: string | undefined;
    extenName?: string | undefined;
    gender?: string | undefined;
    birthDate?: string | undefined;
    buildingNo?: string | undefined;
    street?: string | undefined;
    unitNo?: string | undefined;
    building?: string | undefined;
    province?: string | undefined;
    cityMun?: string | undefined;
    barangay?: string | undefined;
    zipCode?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    employeeEducationalBackgrounds?: EmployeeEducationalBackgroundEntity[] | undefined;
    employeeSkills?: EmployeeSkillEntity[] | undefined;
    employeeWorkExperiences?: EmployeeWorkExperienceEntity[] | undefined;
    departmentEntity?: DepartmentEntity | undefined;
    employeeStatus?: string | undefined;
    uploadImg?: string | undefined;
    uploadResume?: string | undefined;
    dateCreated: Date;
    timeStamp: Date;
}

export class EmployeeEducationalBackgroundEntity implements IEmployeeEducationalBackgroundEntity {
    id!: number;
    schoolName?: string | undefined;
    schoolLocation!: number;
    timestamp!: Date;

    constructor(data?: IEmployeeEducationalBackgroundEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.schoolName = _data["schoolName"];
            this.schoolLocation = _data["schoolLocation"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeEducationalBackgroundEntity {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeEducationalBackgroundEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["schoolName"] = this.schoolName;
        data["schoolLocation"] = this.schoolLocation;
        data["timestamp"] = this.timestamp ? formatDate(this.timestamp) : <any>undefined;
        return data;
    }

    clone(): EmployeeEducationalBackgroundEntity {
        const json = this.toJSON();
        let result = new EmployeeEducationalBackgroundEntity();
        result.init(json);
        return result;
    }
}

export interface IEmployeeEducationalBackgroundEntity {
    id: number;
    schoolName?: string | undefined;
    schoolLocation: number;
    timestamp: Date;
}

export class EmployeeSkillEntity implements IEmployeeSkillEntity {
    id!: number;
    skillName?: string | undefined;
    skillType?: string | undefined;
    timestamp!: Date;

    constructor(data?: IEmployeeSkillEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skillName = _data["skillName"];
            this.skillType = _data["skillType"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeSkillEntity {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeSkillEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skillName"] = this.skillName;
        data["skillType"] = this.skillType;
        data["timestamp"] = this.timestamp ? formatDate(this.timestamp) : <any>undefined;
        return data;
    }

    clone(): EmployeeSkillEntity {
        const json = this.toJSON();
        let result = new EmployeeSkillEntity();
        result.init(json);
        return result;
    }
}

export interface IEmployeeSkillEntity {
    id: number;
    skillName?: string | undefined;
    skillType?: string | undefined;
    timestamp: Date;
}

export class EmployeeWorkExperienceEntity implements IEmployeeWorkExperienceEntity {
    id!: number;
    workExperienceName?: string | undefined;
    workExperiencePosition?: string | undefined;
    workExperienceStarted?: string | undefined;
    workExperienceCompleted?: string | undefined;
    timestamp!: Date;

    constructor(data?: IEmployeeWorkExperienceEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.workExperienceName = _data["workExperienceName"];
            this.workExperiencePosition = _data["workExperiencePosition"];
            this.workExperienceStarted = _data["workExperienceStarted"];
            this.workExperienceCompleted = _data["workExperienceCompleted"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeWorkExperienceEntity {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeWorkExperienceEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workExperienceName"] = this.workExperienceName;
        data["workExperiencePosition"] = this.workExperiencePosition;
        data["workExperienceStarted"] = this.workExperienceStarted;
        data["workExperienceCompleted"] = this.workExperienceCompleted;
        data["timestamp"] = this.timestamp ? formatDate(this.timestamp) : <any>undefined;
        return data;
    }

    clone(): EmployeeWorkExperienceEntity {
        const json = this.toJSON();
        let result = new EmployeeWorkExperienceEntity();
        result.init(json);
        return result;
    }
}

export interface IEmployeeWorkExperienceEntity {
    id: number;
    workExperienceName?: string | undefined;
    workExperiencePosition?: string | undefined;
    workExperienceStarted?: string | undefined;
    workExperienceCompleted?: string | undefined;
    timestamp: Date;
}

export class DepartmentEntity implements IDepartmentEntity {
    id!: number;
    departmentName?: string | undefined;
    timeStamp!: Date;

    constructor(data?: IDepartmentEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.departmentName = _data["departmentName"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DepartmentEntity {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["departmentName"] = this.departmentName;
        data["timeStamp"] = this.timeStamp ? formatDate(this.timeStamp) : <any>undefined;
        return data;
    }

    clone(): DepartmentEntity {
        const json = this.toJSON();
        let result = new DepartmentEntity();
        result.init(json);
        return result;
    }
}

export interface IDepartmentEntity {
    id: number;
    departmentName?: string | undefined;
    timeStamp: Date;
}

export class Response implements IResponse {
    status?: string | undefined;
    message?: string | undefined;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }

    clone(): Response {
        const json = this.toJSON();
        let result = new Response();
        result.init(json);
        return result;
    }
}

export interface IResponse {
    status?: string | undefined;
    message?: string | undefined;
}

export class Departments implements IDepartments {
    id!: number;
    departmentName?: string | undefined;
    timeStamp!: Date;

    constructor(data?: IDepartments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.departmentName = _data["departmentName"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Departments {
        data = typeof data === 'object' ? data : {};
        let result = new Departments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["departmentName"] = this.departmentName;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        return data;
    }

    clone(): Departments {
        const json = this.toJSON();
        let result = new Departments();
        result.init(json);
        return result;
    }
}

export interface IDepartments {
    id: number;
    departmentName?: string | undefined;
    timeStamp: Date;
}

export class Positions implements IPositions {
    id!: number;
    positionName?: string | undefined;
    positionDescription?: string | undefined;
    timeStamp!: Date;

    constructor(data?: IPositions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.positionName = _data["positionName"];
            this.positionDescription = _data["positionDescription"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Positions {
        data = typeof data === 'object' ? data : {};
        let result = new Positions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["positionName"] = this.positionName;
        data["positionDescription"] = this.positionDescription;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        return data;
    }

    clone(): Positions {
        const json = this.toJSON();
        let result = new Positions();
        result.init(json);
        return result;
    }
}

export interface IPositions {
    id: number;
    positionName?: string | undefined;
    positionDescription?: string | undefined;
    timeStamp: Date;
}

export class PositionsVM implements IPositionsVM {
    positionName?: string | undefined;
    positionDescription?: string | undefined;

    constructor(data?: IPositionsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.positionName = _data["positionName"];
            this.positionDescription = _data["positionDescription"];
        }
    }

    static fromJS(data: any): PositionsVM {
        data = typeof data === 'object' ? data : {};
        let result = new PositionsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["positionName"] = this.positionName;
        data["positionDescription"] = this.positionDescription;
        return data;
    }

    clone(): PositionsVM {
        const json = this.toJSON();
        let result = new PositionsVM();
        result.init(json);
        return result;
    }
}

export interface IPositionsVM {
    positionName?: string | undefined;
    positionDescription?: string | undefined;
}

export class DepartmentsVM implements IDepartmentsVM {
    departmentName?: string | undefined;

    constructor(data?: IDepartmentsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentName = _data["departmentName"];
        }
    }

    static fromJS(data: any): DepartmentsVM {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentName"] = this.departmentName;
        return data;
    }

    clone(): DepartmentsVM {
        const json = this.toJSON();
        let result = new DepartmentsVM();
        result.init(json);
        return result;
    }
}

export interface IDepartmentsVM {
    departmentName?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}